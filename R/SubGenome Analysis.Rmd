---
title: "Using Sorghum as an outgroup to find syntenic regions in Maize: regenerating subgenome assignments in maize"
output: html_document
params:
  fileParser: "../Perl/parseKsKnFile.pl"
  goDataFile: "../Data/GO from maizecyc.tab"
  subGenomeFile: "/home/jesse/Dropbox/deleteme/outfile_processed_byHand.tab"
  
  #v1 vs. v1
  synMapOutputFile: "6807_8082.CDS-CDS.lastz.tdd10.cs0.filtered.dag.all.go_D20_g10_A5.aligncoords.gcoords.ks"
  inputDataFile: "../Data/sorghum_v1_vs_maize_v1.tab"
  outputFile: "../Output/recoveredSubGenomes_sorghum_v1_vs_maize_v1.tab"
  log10_ks_cutoff: 0
  
  #v3.1 vs v4+rejected
  # synMapOutputFile: "31607_34889.CDS-CDS.lastz.tdd10.cs0.filtered.dag.all.go_D20_g10_A5.aligncoords.gcoords"
  # inputDataFile: "../Data/sorghum_v3.1_vs_maize_v4+rejected.tab"
  # outputFile: "../Output/recoveredSubGenomes_sorghum_v3.1_vs_maize_v4+rejected.tab"
  # log10_ks_cutoff: 0
  #-0.575
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(readr)
library(readxl)
library(ggplot2)
library(tidyr)
library(dplyr)
library(VennDiagram)
```

This analysis is based on the file: **`r params$inputDataFile`**

We begin with SynMap output based on the [Schnable 2011](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3053962/) paper (see [my notes](https://www.evernote.com/shard/s303/nl/52987123/1ce74f11-98a0-4854-b363-3172e79eeae3) for details on parameter and download options).

# Import SynMap and GO Term Data
***
We parse the SynMap output file with ks/kn values (i.e. a DAGChainer file) to a flat format using a perl script (parseKsKnFile.pl) and import the data into R. Some ks and kn values are empty, which is to be expected. These are ignored for the purposes of finding the median, but included in the results if they are in a block that meets the cutoff criteria. GO terms related to Maize gene models are imported as well.

```{r importSynMapData, include=FALSE}
source("~/git/SubGenomes/R/parseSubgenomes.R")
source("~/git/SubGenomes/R/addGOTerms.R")

# source("C:\\Users\\Jesse\\Documents\\git\\SubGenome\\R\\parseSubgenomes.R")
# source("C:\\Users\\Jesse\\Documents\\git\\SubGenome\\R\\addGOTerms.R")
```

Lets take a look at what we just imported.

***  
 * There were **`r syntelogs.raw %>% nrow()`** rows of data in the SynMap file.
 * There were **`r syntelogs.raw %>% select(gene2) %>% distinct() %>% nrow()`** distinct Maize genes with synteny to Sorghum.
 * Summary of the KS values
     + **`r syntelogs.raw %>% select(ks) %>% summary()`**
 * Out of the `r syntelogs.raw %>% select(gene2) %>% distinct() %>% nrow()` distinct Maize genes with synteny to sorghum, we keep **`r homeologs.genes %>% select(gene2) %>% distinct() %>% nrow()`** after applying the KS cutoff.
 * SubGenome 1
     + **`r subgenome %>% filter(subgenome == "sub1") %>% select(gene2) %>% distinct() %>% nrow()`** genes assigned to subgenome 1
     + **`r goAnnotations.sub1 %>% nrow()`** GO assignments using **`r goAnnotations.sub1 %>% select('GO Term') %>% distinct() %>% nrow()`** GO Terms
 * SubGenome 2
     + **`r subgenome %>% filter(subgenome == "sub2") %>% select(gene2) %>% distinct() %>% nrow()`** genes assigned to subgenome 2
     + **`r goAnnotations.sub2 %>% nrow()`** GO assignments using **`r goAnnotations.sub2 %>% select('GO Term') %>% distinct() %>% nrow()`** GO Terms
 * Rejected
     + **`r subgenome %>% filter(subgenome == "rejected:small") %>% select(gene2) %>% distinct() %>% nrow()`** genes were rejected during subgenome parsing
     (Too few syntenic genes across chromosome)


# Choosing a KS cutoff value
***  
We need to select a cutoff value for ks (synonymous mutation rate) to differentiate between the most recent alpha duplication event and the previous beta duplication. Looking at ks value frequency (left), we should not see any obvious cutoff point.  By transforming ks values to block median values, we should see two (or more) peaks (center). In this (center) graph, the first peak represents orthologs and the second represents homeologs from "pregrass tetraploidy".  If the vertical line separates the first two peaks sufficently, it is probably a good enough value.  If not, we need to pick a new cutoff value for ks. Viewing the log10 transform of the ks values helps differentiate types of homologs (better version of this graph with color can be generated in CoGe).

You have selected the log10(ks) cutoff value to be **`r params$log10_ks_cutoff`**.  Again, this should ideally separate two peaks in the middle graph.

```{r pickKSCutoff, echo=FALSE, fig.width=3, fig.height=3}
qplot(
  syntelogs.mutated$ks[syntelogs.mutated$ks < 2.5], 
  geom="histogram", binwidth=.05, na.rm=TRUE
) + geom_vline(
  mapping = NULL, 
  data = NULL, 
  xintercept = 10^params$log10_ks_cutoff, 
  na.rm = FALSE, 
  show.legend = NA
) + labs(
  title="Frequency of KS values by \nsyntenic block (KS < 2.5)", 
  x="KS value of syntenic block", 
  y="Count (# of genes)"
)

qplot(
  syntelogs.mutated$median_ks[syntelogs.mutated$median_ks < 2.5], 
  geom="histogram", 
  binwidth=.05, 
  na.rm=TRUE
) + geom_vline(
  mapping = NULL, 
  data = NULL, 
  xintercept = 10^params$log10_ks_cutoff, 
  na.rm = FALSE, 
  show.legend = NA
) + labs(
  title="Frequency of median KS \nvalues by syntenic block \n(median KS < 2.5)", 
  x="Median KS value of syntenic block", 
  y="Count (# of genes)"
)

qplot(
  log10(syntelogs.raw$ks), 
  geom="histogram", 
  binwidth=.01, 
  na.rm=TRUE
) + geom_vline(
  mapping = NULL, 
  data = NULL, 
  xintercept = params$log10_ks_cutoff, 
  na.rm = FALSE, 
  show.legend = NA
) + labs(
  title="Frequency of log10 KS \nvalues", 
  x="log10(KS) value of genes", 
  y="Count (# of genes)"
)
```

# Major Syntenic Blocks
***
Regions of synteny are not confined to a 1:1 relationship between Sorghum and Maize chromosomes. Where multiple regions in Maize are syntenic to the same region on Sorghum, we can assume this is a result of the whole genome duplication even.  These are the regions which will be sorted into subgenome 1 and subgenome 2.

```{r reportSyntenicRegions, echo=FALSE, results="asis"}
## Display chromosomes with homeologous genes between org1 and org2
homeologs.chromosome %>%
  select(org_chr1, org_chr2, chromosomeGeneCount) %>%
  spread(org_chr2, chromosomeGeneCount) -> homeologs.spread

homeologs.spread$total <- rowSums(homeologs.spread[-1], na.rm = TRUE)

# De-emphasize na's by turning them light grey
homeologs.spread.formattedTable <- homeologs.spread
homeologs.spread.formattedTable[is.na(homeologs.spread.formattedTable)] <- "<font color=\"lightgrey\">na</font>"
homeologs.spread.formattedTable %>% 
  knitr::kable(caption = "Table", 
               align = "lccccccccccr")
```

There are **<font color=\"darkgreen\">`r homeologs.spread %>% filter(total==0) %>% nrow() %>% replace(is.na(.), 0)`</font>** unaligned sorghum chromosome(s) in the above table. If there are any unaligned sorghum chromosomes, consider picking a new ks cutoff.

# SubGenomes
***
In order to separate subgenome 1 from subgenome 2, we implement a greedy algorithm to collect non-overlapping (when projected on sorghum) syntenic blocks by size. (TODO)

```{r reportSubGenomes, echo=FALSE, results="asis"}
#Positions on each chr with sub 1 or sub 2
#Total genes for each subgenome by chr and overall
```

## Compared to Paper
How many chromosomes with synteny to sorghum were correctly placed in subgenome 1 or subgenome 2? Items in "Paper" only are missed subgenome assignments.  Items in "Test" only are false assignments.  Items in center are correct. (this is an unfair comparison if I sorted by hand)

```{r compareResultsToPaper_chromosomes, echo=FALSE, warning=FALSE, message=FALSE, results='hide', fig.width=4, fig.height=3, fig.align='center'}
subgenome.chromosomes.test <- 
  subgenome.chromosomes %>% 
  mutate(chr1=as.numeric(regmatches(org_chr1, regexpr("\\d*$",org_chr1)))) %>%
  mutate(chr2=as.numeric(regmatches(org_chr2, regexpr("\\d*$",org_chr2)))) %>%
  select(chr1, chr2, subgenome) %>%
  subset(subgenome == "sub1" | subgenome == "sub2")

grid.newpage()
draw.pairwise.venn(
  area1 = subgenome.truth %>% nrow(), 
  area2 = subgenome.chromosomes.test %>% nrow(), 
  cross.area = intersect(subgenome.chromosomes.test, subgenome.truth) %>% nrow(), 
  category = c("Paper", "Test"), 
  lty = rep("blank", 2), 
  fill = c("light blue", "green"), 
  alpha = rep(0.5, 2), 
  cat.pos = c(0, 180), 
  scaled = FALSE,
  euler.d = FALSE, 
  sep.dist = 0.3, 
  rotation.degree = 0
)
```

Genes placed in the "correct" subgenome (TODO)

```{r compareResultsToPaper_genes, echo=FALSE, warning=FALSE, message=FALSE, results='hide', fig.width=4, fig.height=3, fig.align='center'}
#need to import "truth" and compare
#visualize as venn
```

# GOTerms
***
GO Term types by EVCode

```{r GOTerms_by_EVCode, echo=FALSE, warning=FALSE, message=FALSE, results='hide', fig.width=4, fig.height=4}
Type <- c("EV-EXP","EV-COMP")
Count <- c(goAnnotations.mutated %>% filter(grepl("EV-EXP", EVCode)) %>% nrow(),
      goAnnotations.mutated %>% filter(grepl("EV-COMP", EVCode)) %>% nrow())
df = data.frame(Type,Count)
ggplot(data=df, aes(x=Type, y=Count)) +
  geom_bar(stat="identity", fill="steelblue") +
  geom_text(aes(label=Count), vjust=-0.3, size=3.5)
```

GO Term by subgenome (All EV-Codes)

```{r GOTerms_by_subgenome, echo=FALSE, warning=FALSE, message=FALSE, results='hide', fig.width=4, fig.height=4}
# All EV-Codes, Unique GO Terms
grid.newpage()
draw.pairwise.venn(
  area1 = goAnnotations.sub1 %>% select("GO Term") %>% distinct() %>% nrow(),
  area2 = goAnnotations.sub2 %>% select("GO Term") %>% distinct() %>% nrow(),
  cross.area = intersect(goAnnotations.sub1 %>% select("GO Term"), goAnnotations.sub2 %>% select("GO Term")) %>% nrow(), 
  category = c("SubGenome 1", "SubGenome 2"), 
  lty = rep("blank", 2), 
  fill = c("light blue", "green"), 
  alpha = rep(0.5, 2), 
  cat.pos = c(0, 180), 
  scaled = FALSE,
  euler.d = FALSE, 
  sep.dist = 0.3, 
  rotation.degree = 0
)

#EXP only, Unique GO Terms
grid.newpage()
draw.pairwise.venn(
  area1 = goAnnotations.sub1 %>% filter(grepl("EV-EXP", EVCode)) %>% select("GO Term") %>% distinct() %>% nrow(),
  area2 = goAnnotations.sub2 %>% filter(grepl("EV-EXP", EVCode)) %>% select("GO Term") %>% distinct() %>% nrow(),
  cross.area = intersect(goAnnotations.sub1 %>% filter(grepl("EV-EXP", EVCode)) %>% select("GO Term"), 
                         goAnnotations.sub2 %>% filter(grepl("EV-EXP", EVCode)) %>% select("GO Term")
                         ) %>% nrow(), 
  category = c("SubGenome 1", "SubGenome 2"), 
  lty = rep("blank", 2), 
  fill = c("light blue", "green"), 
  alpha = rep(0.5, 2), 
  cat.pos = c(0, 180), 
  scaled = FALSE,
  euler.d = FALSE, 
  sep.dist = 0.3, 
  rotation.degree = 0
)
```

GOTerm assignments to genes by subgenome (All EV-Codes)
(broken - doesn't take into account homeologous genes - try replacing equivalent genes from homeolog list)

```{r GOTerms_assignments_by_subgenome, echo=FALSE, warning=FALSE, message=FALSE, results='hide', fig.width=4, fig.height=4}
# All EV-Codes, all assignments
grid.newpage()
draw.pairwise.venn(
  area1 = goAnnotations.sub1 %>% nrow(),
  area2 = goAnnotations.sub2 %>% nrow(),
  cross.area = intersect(goAnnotations.sub1 %>% select(gene2, "GO Term"), goAnnotations.sub2 %>% select(gene2, "GO Term")) %>% nrow(), 
  category = c("SubGenome 1", "SubGenome 2"), 
  lty = rep("blank", 2), 
  fill = c("light blue", "green"), 
  alpha = rep(0.5, 2), 
  cat.pos = c(0, 180), 
  scaled = FALSE,
  euler.d = FALSE, 
  sep.dist = 0.3, 
  rotation.degree = 0
)

#EXP only, all assignments
grid.newpage()
draw.pairwise.venn(
  area1 = goAnnotations.sub1 %>% filter(grepl("EV-EXP", EVCode)) %>% nrow(),
  area2 = goAnnotations.sub2 %>% filter(grepl("EV-EXP", EVCode)) %>% nrow(),
  cross.area = intersect(goAnnotations.sub1 %>% filter(grepl("EV-EXP", EVCode)) %>% select(gene2, "GO Term"), 
                         goAnnotations.sub2 %>% filter(grepl("EV-EXP", EVCode)) %>% select(gene2, "GO Term")
                         ) %>% nrow(), 
  category = c("SubGenome 1", "SubGenome 2"), 
  lty = rep("blank", 2), 
  fill = c("light blue", "green"), 
  alpha = rep(0.5, 2), 
  cat.pos = c(0, 180), 
  scaled = FALSE,
  euler.d = FALSE, 
  sep.dist = 0.3, 
  rotation.degree = 0
)
```

# Wrapup
***

The results of this report are available at **`r params$outputFile`**.

```{r writeSubgenomesToFile, echo=FALSE}
## Now recover which genes are in these sets
#write.table(subgenome, params$outputFile, sep="\t")
```
