---
title: 'Using Sorghum as an outgroup to find syntenic regions in Maize: regenerating
  subgenome assignments in maize'
params:
  log10_ks_cutoff: 0
output:
  html_document: default
  pdf_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

We begin with SynMap output based on the [Schnable 2011](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3053962/) paper (see [my notes](https://www.evernote.com/shard/s303/nl/52987123/1ce74f11-98a0-4854-b363-3172e79eeae3) for details on parameter and download options).

Expression data was retrieved from [NCBI: GSE50191](https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE50191) and was reported in [Walley 2016](http://science.sciencemag.org/content/353/6301/814.full).  This set includes 69 experiments (3 biological replicates, 23 tissues) for 62,547 mRNAs aligned to Zea mays B73 RefGen_v2 5a WGS annotation set.

# Import SynMap and GO Term Data
***
We parse the SynMap output file with ks/kn values (i.e. a DAGChainer file) to a flat format using a perl script (parseKsKnFile.pl) and import the data into R. Some ks and kn values are empty, which is to be expected. These are ignored for the purposes of finding the median, but included in the results if they are in a block that meets the cutoff criteria. GO terms related to Maize gene models are imported as well.

```{r importSynMapData, include=FALSE}
load("~/git/SubGenomes/Data/SavedObjects/loadedData.RData")

# source("~/git/SubGenomes/R/loadData.R")
# source("~/git/SubGenomes/R/cleanData.R")
source("~/git/SubGenomes/R/functions.R")
source("~/git/SubGenomes/R/do.R")

# source("~/git/SubGenomes/R/parseSubgenomes.R")
# source("~/git/SubGenomes/R/addGOTerms.R")
# source("~/git/SubGenomes/R/parseGOSlim.R")
# source("~/git/SubGenomes/R/createTopGO.R")
# source("~/git/SubGenomes/R/parseExpressionData.R")

# source("C:\\Users\\Jesse\\Documents\\git\\SubGenome\\R\\loadData.R")
# source("C:\\Users\\Jesse\\Documents\\git\\SubGenome\\R\\cleanData.R")
# source("C:\\Users\\Jesse\\Documents\\git\\SubGenome\\R\\parseSubgenomes.R")
# source("C:\\Users\\Jesse\\Documents\\git\\SubGenome\\R\\addGOTerms.R")
# source("C:\\Users\\Jesse\\Documents\\git\\SubGenome\\R\\parseGOSlim.R")
# # source("C:\\Users\\Jesse\\Documents\\git\\SubGenome\\R\\createTopGO.R")
# source("C:\\Users\\Jesse\\Documents\\git\\SubGenome\\R\\parseExpressionData.R")

library(topGO)
library(readr)
library(readxl)
library(ggplot2)
library(tidyr)
library(dplyr)
library(VennDiagram)
library(gridExtra)

# topGO::groupGOTerms()
# MFterms <- ls(GOMFTerm)
# BPterms <- ls(GOBPTerm)
# CCterms <- ls(GOCCTerm)
```

Lets take a look at what we just imported.

***  
 * There were **`r syntelogs.sorghum.v3.1.maize.v4.and.rejected.clean %>% nrow()`** rows of data in the SynMap file.
 * There were **`r syntelogs.sorghum.v3.1.maize.v4.and.rejected.clean %>% select(gene2) %>% distinct() %>% nrow()`** distinct Maize genes with synteny to Sorghum.
 * Summary of the KS values
     + **`r syntelogs.sorghum.v3.1.maize.v4.and.rejected.clean %>% select(ks) %>% summary()`**
 * Out of the `r syntelogs.sorghum.v3.1.maize.v4.and.rejected.clean %>% select(gene2) %>% distinct() %>% nrow()` distinct Maize genes with synteny to sorghum, we keep **`r homeologs.genes %>% select(gene2) %>% distinct() %>% nrow()`** after applying the KS cutoff.
 * SubGenome 1
     + **`r subgenome %>% filter(subgenome == "sub1") %>% select(gene2) %>% distinct() %>% nrow()`** genes assigned to subgenome 1
     + **`r subgenome %>% filter(subgenome == "sub1") %>% filter(gene2 %in% expressedGenes$geneID) %>% select(gene2) %>% distinct() %>% nrow()`** genes assigned            to subgenome 1 that are expressed significantly on average over 68 samples
     + **`r goAnnotations.sub1 %>% nrow()`** GO assignments using **`r goAnnotations.sub1 %>% select(goTerm) %>% distinct() %>% nrow()`** GO Terms
 * SubGenome 2
     + **`r subgenome %>% filter(subgenome == "sub2") %>% select(gene2) %>% distinct() %>% nrow()`** genes assigned to subgenome 2
     + **`r subgenome %>% filter(subgenome == "sub2") %>% filter(gene2 %in% expressedGenes$geneID) %>% select(gene2) %>% distinct() %>% nrow()`** genes assigned            to subgenome 2 that are expressed significantly on average over 68 samples
     + **`r goAnnotations.sub2 %>% nrow()`** GO assignments using **`r goAnnotations.sub2 %>% select(goTerm) %>% distinct() %>% nrow()`** GO Terms
 * Rejected
     + **`r subgenome %>% filter(subgenome == "rejected:small") %>% select(gene2) %>% distinct() %>% nrow()`** genes were rejected during subgenome parsing
     (Too few syntenic genes across chromosome)


# Choosing a KS cutoff value
***  
We need to select a cutoff value for ks (synonymous mutation rate) to differentiate between the most recent alpha duplication event and the previous beta duplication. Looking at ks value frequency (left), we should not see any obvious cutoff point.  By transforming ks values to block median values, we should see two (or more) peaks (center). In this (center) graph, the first peak represents orthologs and the second represents homeologs from "pregrass tetraploidy".  If the vertical line separates the first two peaks sufficently, it is probably a good enough value.  If not, we need to pick a new cutoff value for ks. Viewing the log10 transform of the ks values helps differentiate types of homologs (better version of this graph with color can be generated in CoGe).

You have selected the log10(ks) cutoff value to be **`r params$log10_ks_cutoff`**.  Again, this should ideally separate two peaks in the middle graph.

```{r pickKSCutoff, echo=FALSE, fig.width=3, fig.height=3}
qplot(
  syntelogs.mutated$ks[syntelogs.mutated$ks < 2.5], 
  geom="histogram", binwidth=.05, na.rm=TRUE
) + geom_vline(
  mapping = NULL, 
  data = NULL, 
  xintercept = 10^params$log10_ks_cutoff, 
  na.rm = FALSE, 
  show.legend = NA
) + labs(
  title="Frequency of KS values by \nsyntenic block (KS < 2.5)", 
  x="KS value of syntenic block", 
  y="Count (# of genes)"
)

qplot(
  syntelogs.mutated$median_ks[syntelogs.mutated$median_ks < 2.5], 
  geom="histogram", 
  binwidth=.05, 
  na.rm=TRUE
) + geom_vline(
  mapping = NULL, 
  data = NULL, 
  xintercept = 10^params$log10_ks_cutoff, 
  na.rm = FALSE, 
  show.legend = NA
) + labs(
  title="Frequency of median KS \nvalues by syntenic block \n(median KS < 2.5)", 
  x="Median KS value of syntenic block", 
  y="Count (# of genes)"
)

qplot(
  log10(syntelogs.sorghum.v3.1.maize.v4.and.rejected.clean$ks), 
  geom="histogram", 
  binwidth=.01, 
  na.rm=TRUE
) + geom_vline(
  mapping = NULL, 
  data = NULL, 
  xintercept = params$log10_ks_cutoff, 
  na.rm = FALSE, 
  show.legend = NA
) + labs(
  title="Frequency of log10 KS \nvalues", 
  x="log10(KS) value of genes", 
  y="Count (# of genes)"
)
```

# Major Syntenic Blocks
***
Regions of synteny are not confined to a 1:1 relationship between Sorghum and Maize chromosomes. Where multiple regions in Maize are syntenic to the same region on Sorghum, we can assume this is a result of the whole genome duplication even.  These are the regions which will be sorted into subgenome 1 and subgenome 2.

```{r reportSyntenicRegions, echo=FALSE, results="asis"}
## Display chromosomes with homeologous genes between org1 and org2
homeologs.chromosome %>%
  select(org_chr1, org_chr2, chromosomeGeneCount) %>%
  spread(org_chr2, chromosomeGeneCount) -> homeologs.spread

homeologs.spread$total <- rowSums(homeologs.spread[-1], na.rm = TRUE)

# De-emphasize na's by turning them light grey
homeologs.spread.formattedTable <- data.frame(rbind(homeologs.spread[-c(2),], homeologs.spread[c(2),]))
homeologs.spread.formattedTable <- cbind(homeologs.spread.formattedTable[,-c(3, 12)], homeologs.spread.formattedTable[,c(3, 12)])
homeologs.spread.formattedTable <- rename(homeologs.spread.formattedTable, Chromosome=org_chr1)
homeologs.spread.formattedTable[is.na(homeologs.spread.formattedTable)] <- "<font color=\"lightgrey\">na</font>"
homeologs.spread.formattedTable %>% 
  knitr::kable(caption = "Table", 
               align = "lccccccccccr")
```

There are **<font color=\"darkgreen\">`r homeologs.spread %>% filter(total==0) %>% nrow() %>% replace(is.na(.), 0)`</font>** unaligned sorghum chromosome(s) in the above table. If there are any unaligned sorghum chromosomes, consider picking a new ks cutoff.

# SubGenomes
***
In order to separate subgenome 1 from subgenome 2, we implement a greedy algorithm to collect non-overlapping (when projected on sorghum) syntenic blocks by size. 
Psuedocode of the algorithm is as follows: foreach sorghum chromosome, set the largest syntenic chromosome (by gene) as sub1.  Foreach additional syntenic chromosome if doesn't overlap what is already in sub1, add it to sub1. Else, if it does not overlap anything in sub2, add to sub2.  Else toss.  After all syntenic chromosomes are process for this sorghum chromosome, count the number of genes in sub1 and sub2.  If sub2 is bigger, switch them.  *Toss out "small" syntenic chromosomes (51 genes or less?), and consider a tolerance for how much overlap must occur to consider it a true overlap.  Also consider switching to gene level overlap rather than whole-chromosome start/stop values.

```{r reportSubGenomes, echo=FALSE, results="asis"}
#Positions on each chr with sub 1 or sub 2
#Total genes for each subgenome by chr and overall
```

In order to see if one subgenome tends to have more isoforms, we plot the density of isoform counts from each subgenome based on isoforms in the v4 release 32 GFF file. We scale the x axis using log10, as we have a very long tail on this data (i.e. most counts are 1, but a few range to nearly 600). The densities track each other very strongly, so there isn't likely anything to look for here.

```{r subgenome_isoform_counts, echo=FALSE, warning=FALSE, message=FALSE, results='hide', fig.width=6, fig.height=4, fig.align='center'}
## Plot frequency of isoform counts for each gene
data <- geneTranscript.counts %>% inner_join(subgenome, by=c("gene"="gene2")) %>% select(gene, n, subgenome) %>% filter(subgenome=="sub1" | subgenome=="sub2")
ggplot(data, aes(n,color=subgenome)) + 
  geom_density() + 
  scale_x_log10() +
  labs(y = "Density (Isoform Counts)", 
       x = "log10(Isoform Counts)", 
       title = "Comparison of Density of Isoform Counts between\nGenes in Subgenome 1 and Subgenome 2"
  )
```

## Compared to Paper
How many chromosomes with synteny to sorghum were correctly placed in subgenome 1 or subgenome 2? Items in "Paper" only are missed subgenome assignments.  Items in "Greedy" only are false assignments.  Items in center are correct. (currently sorted by hand)

```{r compareResultsToPaper_chromosomes, echo=FALSE, warning=FALSE, message=FALSE, results='hide', fig.width=4, fig.height=3, fig.align='center'}
subgenome.chromosomes.test <- 
  subgenome.assignments %>% 
  mutate(chr1=as.numeric(regmatches(org_chr1, regexpr("\\d*$",org_chr1)))) %>%
  mutate(chr2=as.numeric(regmatches(org_chr2, regexpr("\\d*$",org_chr2)))) %>%
  select(chr1, chr2, subgenome) %>%
  subset(subgenome == "sub1" | subgenome == "sub2")

grid.newpage()
g = draw.pairwise.venn(
  area1 = subgenome.truth %>% nrow(), 
  area2 = subgenome.chromosomes.test %>% nrow(), 
  cross.area = intersect(subgenome.chromosomes.test, subgenome.truth) %>% nrow(), 
  category = c("Paper", "Greedy"), 
  lty = rep("blank", 2), 
  fill = c("light blue", "green"), 
  alpha = rep(0.5, 2), 
  cat.pos = c(0, 180), 
  scaled = FALSE,
  euler.d = FALSE, 
  sep.dist = 0.3, 
  rotation.degree = 0,
  ind = FALSE
)
grid.arrange(gTree(children=g), top="Overlap of Subgenome Assignments vs. \"Truth\"")
```

<!-- print("Missed subgenome assignments:") -->
<!-- setdiff(subgenome.truth, subgenome.chromosomes.test) -->

<!-- print("False positive subgenome assignments:") -->
<!-- setdiff(subgenome.chromosomes.test, subgenome.truth) -->

# GO Terms in Maize
***

First we show both how many unique GO terms have been assigned using a computational ev-code vs. an experimental ev-code. A few terms have been annotated using both or were assigned multiple times based on different publications, which is why n is greater than the number of unique GO terms in our set. We also break down the GO terms by type.  A few terms may not have a type, typically because they have been made obsolete.

Second, we look at the same divisions but this time for all gene annotations (i.e. gene + GO Term + Ev-Code). Again, since some terms are assigned computationally and experimentally to the same gene or assigned multiple times based on different publications, n is greater than the number of unique GO term assignments in out set. The main takeaways here are that computationally assigned GO terms vastly outnumber experimental annotations, most annotations use MF terms, and there are a few terms falling through the cracks most likely due to being outdated.

```{r GOTerms_in_Maize, echo=FALSE, warning=FALSE, message=FALSE, results='hide', fig.width=2.3, fig.height=3.6}
Evidence <- c("EV-EXP","EV-COMP")
Count <- c(go.maize.clean %>% filter(evCode=="EXP") %>% select(goTerm) %>% distinct() %>% nrow(),
      go.maize.clean %>% filter(evCode=="COMP") %>% select(goTerm) %>% distinct() %>% nrow())
df = data.frame(Evidence,Count)
ggplot(data=df, aes(x=Evidence, y=Count)) +
  geom_bar(stat="identity", fill="steelblue") +
  geom_text(aes(label=Count), vjust=-0.3, size=3.5
) + labs(
  title=paste("GO Terms by EV Code\n(n=", nrow(unique(go.maize.clean[,c("goTerm", "evCode")])),")", sep = "")
) + theme(plot.title = element_text(size = rel(.8)))

Type <- c("MF","BP","CC","<NA>")
Count <- c(go.maize.clean %>% filter(type=="MF") %>% select(goTerm) %>% distinct() %>% nrow(),
           go.maize.clean %>% filter(type=="BP") %>% select(goTerm) %>% distinct() %>% nrow(),
           go.maize.clean %>% filter(type=="CC") %>% select(goTerm) %>% distinct() %>% nrow(),
           go.maize.clean %>% filter(is.na(type)) %>% select(goTerm) %>% distinct() %>% nrow())
df = data.frame(Type,Count)
ggplot(data=df, aes(x=Type, y=Count)) +
  geom_bar(stat="identity", fill="steelblue") +
  geom_text(aes(label=Count), vjust=-0.3, size=3.5
) + labs(
  title=paste("GO Terms by Type\n(n=", nrow(unique(go.maize.clean[,c("goTerm", "type")])),")", sep = "")
) + theme(plot.title = element_text(size = rel(.8)))

Evidence <- c("EV-EXP","EV-COMP")
Count <- c(go.maize.clean %>% filter(evCode=="EXP") %>% nrow(),
      go.maize.clean %>% filter(evCode=="COMP") %>% nrow())
df = data.frame(Evidence,Count)
ggplot(data=df, aes(x=Evidence, y=Count)) +
  geom_bar(stat="identity", fill="steelblue") +
  geom_text(aes(label=Count), vjust=-0.3, size=3.5
) + labs(
  title=paste("GO Term Annotations by\nEV Code (n=", nrow(go.maize.clean),")", sep = "")
) + theme(plot.title = element_text(size = rel(.8)))

Type <- c("MF","BP","CC","<NA>")
Count <- c(go.maize.clean %>% filter(type=="MF") %>% select(geneID, goTerm, evCode) %>% distinct() %>% nrow(),
           go.maize.clean %>% filter(type=="BP") %>% select(geneID, goTerm, evCode) %>% distinct() %>% nrow(),
           go.maize.clean %>% filter(type=="CC") %>% select(geneID, goTerm, evCode) %>% distinct() %>% nrow(),
           go.maize.clean %>% filter(is.na(type)) %>% select(geneID, goTerm, evCode) %>% distinct() %>% nrow())
df = data.frame(Type,Count)
ggplot(data=df, aes(x=Type, y=Count)) +
  geom_bar(stat="identity", fill="steelblue") +
  geom_text(aes(label=Count), vjust=-0.3, size=3.5
) + labs(
  title=paste("GO Term Annotations by\nType (n=", nrow(unique(go.maize.clean[,c("geneID","goTerm","evCode","type")])),")", sep = "")
) + theme(plot.title = element_text(size = rel(.8)))
```

# GO Term Comparison by Subgenome
***

GO Terms by subgenome.  If the GO Term is assigned to any gene in the subgenome, it is counted once for that subgenome.  This is a presence/absence test.

The main takeaways here are that 1) there are differences in functional assignments between each subgenome, regardless of which filters I apply.  2) the GOSlim for plants is extremely restrictive, and probably not useful.  3) Sub1 has more functional assignments than sub2, although this may be a direct correlation to the larger size (by definition) of sub1.

```{r GOTerms_by_subgenome, echo=FALSE, warning=FALSE, message=FALSE, results='hide', fig.width=3, fig.height=3}
# All EV-Codes
grid.newpage()
g <- draw.pairwise.venn(
  area1 = goAnnotations.sub1 %>% select(goTerm) %>% distinct() %>% nrow(),
  area2 = goAnnotations.sub2 %>% select(goTerm) %>% distinct() %>% nrow(),
  cross.area = intersect(goAnnotations.sub1 %>% select(goTerm), goAnnotations.sub2 %>% select(goTerm)) %>% nrow(), 
  category = c("Sub1", "Sub2"), 
  lty = rep("blank", 2), 
  fill = c("light blue", "green"), 
  alpha = rep(0.5, 2), 
  cat.pos = c(0, 180), 
  scaled = FALSE,
  euler.d = FALSE, 
  sep.dist = 0.3, 
  rotation.degree = 0,
  ind = FALSE
)
grid.arrange(gTree(children=g), top="GO Term by Subgenome\n(All EV-Codes)")

# All EV-Codes, GOSlim only
grid.newpage()
g <- draw.pairwise.venn(
  area1 = goAnnotations.sub1 %>% inner_join(go.goSlim.plant, by=c(goTerm = "GOSlimTerm")) %>% select(goTerm) %>% distinct() %>% nrow(),
  area2 = goAnnotations.sub2 %>% inner_join(go.goSlim.plant, by=c(goTerm = "GOSlimTerm")) %>% select(goTerm) %>% distinct() %>% nrow(),
  cross.area = intersect(goAnnotations.sub1 %>% inner_join(go.goSlim.plant, by=c(goTerm = "GOSlimTerm")) %>% select(goTerm), 
                         goAnnotations.sub2 %>% inner_join(go.goSlim.plant, by=c(goTerm = "GOSlimTerm")) %>% select(goTerm)) %>% 
              nrow(), 
  category = c("Sub1", "Sub2"), 
  lty = rep("blank", 2), 
  fill = c("light blue", "green"), 
  alpha = rep(0.5, 2), 
  cat.pos = c(0, 180), 
  scaled = FALSE,
  euler.d = FALSE, 
  sep.dist = 0.3, 
  rotation.degree = 0,
  ind = FALSE
)
grid.arrange(gTree(children=g), top="GO Term by Subgenome\n(All EV-Codes, GOSlim only)")

# All EV-Codes, MF terms only
grid.newpage()
g <- draw.pairwise.venn(
  area1 = goAnnotations.sub1 %>% filter(type=="MF") %>% select(goTerm) %>% distinct() %>% nrow(),
  area2 = goAnnotations.sub2 %>% filter(type=="MF") %>% select(goTerm) %>% distinct() %>% nrow(),
  cross.area = intersect(goAnnotations.sub1 %>% filter(type=="MF") %>% select(goTerm), 
                         goAnnotations.sub2 %>% filter(type=="MF") %>% select(goTerm)) %>%
                          nrow(), 
  category = c("Sub1", "Sub2"), 
  lty = rep("blank", 2), 
  fill = c("light blue", "green"), 
  alpha = rep(0.5, 2), 
  cat.pos = c(0, 180), 
  scaled = FALSE,
  euler.d = FALSE, 
  sep.dist = 0.3, 
  rotation.degree = 0,
  ind = FALSE
)
grid.arrange(gTree(children=g), top="GO Term by Subgenome\n(All EV-Codes, MF only)")

#EXP only
grid.newpage()
g <- draw.pairwise.venn(
  area1 = goAnnotations.sub1 %>% filter(evCode=="EXP") %>% select(goTerm) %>% distinct() %>% nrow(),
  area2 = goAnnotations.sub2 %>% filter(evCode=="EXP") %>% select(goTerm) %>% distinct() %>% nrow(),
  cross.area = intersect(goAnnotations.sub1 %>% filter(evCode=="EXP") %>% select(goTerm), 
                         goAnnotations.sub2 %>% filter(evCode=="EXP") %>% select(goTerm)
                         ) %>% nrow(), 
  category = c("Sub1", "Sub2"), 
  lty = rep("blank", 2), 
  fill = c("light blue", "green"), 
  alpha = rep(0.5, 2), 
  cat.pos = c(0, 180), 
  scaled = FALSE,
  euler.d = FALSE, 
  sep.dist = 0.3, 
  rotation.degree = 0,
  ind = FALSE
)
grid.arrange(gTree(children=g), top="GO Term by Subgenome\n(EV-EXP only)")

#EXP only, GOSlim only
grid.newpage()
g <- draw.pairwise.venn(
  area1 = goAnnotations.sub1 %>% inner_join(go.goSlim.plant, by=c(goTerm = "GOSlimTerm")) %>% filter(evCode=="EXP") %>% select(goTerm) %>% distinct() %>% nrow(),
  area2 = goAnnotations.sub2 %>% inner_join(go.goSlim.plant, by=c(goTerm = "GOSlimTerm")) %>% filter(evCode=="EXP") %>% select(goTerm) %>% distinct() %>% nrow(),
  cross.area = intersect(goAnnotations.sub1 %>% inner_join(go.goSlim.plant, by=c(goTerm = "GOSlimTerm"))%>% filter(evCode=="EXP") %>% select(goTerm), 
                         goAnnotations.sub2 %>% inner_join(go.goSlim.plant, by=c(goTerm = "GOSlimTerm")) %>% filter(evCode=="EXP") %>% select(goTerm)
                         ) %>% nrow(), 
  category = c("Sub1", "Sub2"), 
  lty = rep("blank", 2), 
  fill = c("light blue", "green"), 
  alpha = rep(0.5, 2), 
  cat.pos = c(0, 180), 
  scaled = FALSE,
  euler.d = FALSE, 
  sep.dist = 0.3, 
  rotation.degree = 0,
  ind = FALSE
)
grid.arrange(gTree(children=g), top="GO Term by Subgenome\n(EV-EXP, GOSlim only)")

#EXP only, MF terms only
grid.newpage()
g <- draw.pairwise.venn(
  area1 = goAnnotations.sub1 %>% filter(evCode=="EXP") %>% filter(type=="MF") %>% select(goTerm) %>% distinct() %>% nrow(),
  area2 = goAnnotations.sub2 %>% filter(evCode=="EXP") %>% filter(type=="MF") %>% select(goTerm) %>% distinct() %>% nrow(),
  cross.area = intersect(goAnnotations.sub1 %>% filter(evCode=="EXP") %>% filter(type=="MF") %>% select(goTerm), 
                         goAnnotations.sub2 %>% filter(evCode=="EXP") %>% filter(type=="MF") %>% select(goTerm)
                         ) %>% nrow(), 
  category = c("Sub1", "Sub2"), 
  lty = rep("blank", 2), 
  fill = c("light blue", "green"), 
  alpha = rep(0.5, 2), 
  cat.pos = c(0, 180), 
  scaled = FALSE,
  euler.d = FALSE, 
  sep.dist = 0.3, 
  rotation.degree = 0,
  ind = FALSE
)
grid.arrange(gTree(children=g), top="GO Term by Subgenome\n(EV-EXP, MF only)")
```

***

GO Term assignments to genes by subgenome, which takes into account the gene-GO Term pairings and considers homeologs equivalent for the purposes of determining overlap in assignments.

The main takeaways here mirror the assessment from the GO Term presence/absence check above. There are many differences in assignments, although we can assume that the same terms are reused very often based on the differenced between unique terms and gene annotations.

```{r GOTerms_assignments_by_subgenome, echo=FALSE, warning=FALSE, message=FALSE, results='hide', fig.width=3, fig.height=3}
## Only keep genes where there is a duplicate still on subgenome 1 and subgenome 2.  The converted data.frame will hold maize2 genes with the names replaced with maize1 homologs
converted <-
  homeologs.pairs %>%
  subset(Maize1 != "" & Maize2 != "") %>%
  right_join(., goAnnotations.sub2,by=c("Maize2"="gene2"))
converted$Maize2[!is.na(converted$Maize1)] <- as.character(converted$Maize1[!is.na(converted$Maize1)])
converted <- 
  converted %>%
  select(Maize2, goTerm, evCode, type) %>%
  rename(gene2=Maize2)

# All EV-Codes, all assignments
grid.newpage()
g <- draw.pairwise.venn(
  area1 = goAnnotations.sub1 %>% nrow(),
  area2 = converted %>% nrow(),
  cross.area = intersect(goAnnotations.sub1 %>% select(gene2, goTerm) %>% distinct(), 
                         converted %>% select(gene2, goTerm) %>% distinct()
                         ) %>% nrow(),
  category = c("Sub1", "Sub2"), 
  lty = rep("blank", 2), 
  fill = c("light blue", "green"), 
  alpha = rep(0.5, 2), 
  cat.pos = c(0, 180), 
  scaled = FALSE,
  euler.d = FALSE, 
  sep.dist = 0.3, 
  rotation.degree = 0,
  ind = FALSE
)
grid.arrange(gTree(children=g), top="GO Term Assignments by Subgenome\n(All EV-Codes)")

#EXP only, all assignments
grid.newpage()
g <- draw.pairwise.venn(
  area1 = goAnnotations.sub1 %>% filter(evCode=="EXP") %>% nrow(),
  area2 = converted %>% filter(evCode=="EXP") %>% nrow(),
  cross.area = intersect(goAnnotations.sub1 %>% filter(evCode=="EXP") %>% select(gene2, goTerm) %>% distinct(), 
                         converted %>% filter(evCode=="EXP") %>% select(gene2, goTerm) %>% distinct()
                         ) %>% nrow(), 
  category = c("Sub1", "Sub2"), 
  lty = rep("blank", 2), 
  fill = c("light blue", "green"), 
  alpha = rep(0.5, 2), 
  cat.pos = c(0, 180), 
  scaled = FALSE,
  euler.d = FALSE, 
  sep.dist = 0.3, 
  rotation.degree = 0,
  ind = FALSE
)
grid.arrange(gTree(children=g), top="GO Term Assignments by Subgenome\n(EV-EXP only)")

#EXP only, MF only
grid.newpage()
g <- draw.pairwise.venn(
  area1 = goAnnotations.sub1 %>% filter(evCode=="EXP") %>% filter(type=="MF") %>% nrow(),
  area2 = converted %>% filter(evCode=="EXP") %>% filter(type=="MF") %>% nrow(),
  cross.area = intersect(goAnnotations.sub1 %>% filter(evCode=="EXP") %>% filter(type=="MF") %>% select(gene2, goTerm) %>% distinct(), 
                         converted %>% filter(evCode=="EXP") %>% filter(type=="MF") %>% select(gene2, goTerm) %>% distinct()
                         ) %>% nrow(), 
  category = c("Sub1", "Sub2"), 
  lty = rep("blank", 2), 
  fill = c("light blue", "green"), 
  alpha = rep(0.5, 2), 
  cat.pos = c(0, 180), 
  scaled = FALSE,
  euler.d = FALSE, 
  sep.dist = 0.3, 
  rotation.degree = 0,
  ind = FALSE
)
grid.arrange(gTree(children=g), top="GO Term Assignments by Subgenome\n(EV-EXP, MF only)")
```

# Expression

***

Cases where the maize1 homolog is more or less expressed than the maize2 homolog

```{r diffExpression_subgenome, echo=FALSE, warning=FALSE, message=FALSE, results='hide', fig.width=4, fig.height=4, fig.align='center'}
# Expression Diffs
grid.newpage()
g <- draw.pairwise.venn(
  area1 = expressedPairs %>% subset((FPKM_mean1/FPKM_mean2) < 2) %>% nrow(),
  area2 = expressedPairs %>% subset((FPKM_mean2/FPKM_mean1) < 2) %>% nrow(),
  cross.area = intersect(expressedPairs %>% subset((FPKM_mean1/FPKM_mean2) < 2),
                         expressedPairs %>% subset((FPKM_mean2/FPKM_mean1) < 2)) %>%
                          nrow(), 
  category = c("Sub1", "Sub2"), 
  lty = rep("blank", 2), 
  fill = c("light blue", "green"), 
  alpha = rep(0.5, 2), 
  cat.pos = c(0, 180), 
  scaled = FALSE,
  euler.d = FALSE, 
  sep.dist = 0.3, 
  rotation.degree = 0,
  ind = FALSE
)
grid.arrange(gTree(children=g), top="Genes with 2-fold higher\nexpression by subgenome")
```

Overall expression patterns between subgenome 1 and subgenome 2 are highly similar.  Below we show to views of the same data.  In the density graph, we can see that subgenome 1 is slightly shifted to the right of subgenome 2 expression, but otherwise follows the same shape.  Viewed as a boxplot, you can again see that the quartiles in subgenome 1 and 2 are largely the same.  This also shows a few high expressing outliers on subgenome 1.

Paired t-test suggests that there is no difference in means between FPKM of homeologs in sub1 vs. sub2 (p-val > 0.05, so we accept null hypothesis of equal means):
```{r subgenome_fpkm_ttest, echo=FALSE}
t.test(x=expressedPairs$FPKM_mean1, y=expressedPairs$FPKM_mean2, paired = TRUE)
```

```{r subgenome_expression_frequency, echo=FALSE, warning=FALSE, message=FALSE, results='hide', fig.width=4.5, fig.height=4}
## Plot frequency of isoform counts for each gene
data <- expressedGenes %>% inner_join(subgenome, by=c("geneID"="gene2")) %>% select(geneID, FPKM_mean, subgenome) %>% filter(subgenome=="sub1" | subgenome=="sub2")
ggplot(data, aes(FPKM_mean,color=subgenome)) +
  geom_density() +
  scale_x_log10() +
  labs(y = "Density (FPKM)",
       x = "log10(FPKM)",
       title = "Comparison of FPKM Expression between\nGenes in Subgenome 1 and Subgenome 2"
  )

ggplot(data, aes(subgenome,log10(FPKM_mean))) +
  geom_boxplot() +
  labs(y = "log10(FPKM)",
       x = "Subgenome",
       title = "Comparison of FPKM Expression between\nGenes in Subgenome 1 and Subgenome 2"
  )
```

I am curious if our definition of sub 1 and sub 2 (i.e. the larger syntenic block is defined as sub 1) is really the best way to decide which genes are in sub 1 and sub 2. It seems to me that if one could resonably expect that, given 2 identically duplicate genes, if there was no benefit to having duplicated function then it would be a matter of random chance which of the two duplicate genes would loose function over time.  It also seems to me that the quickest way to "degrade" an unnecessary gene (evolutionarily speaking) is to reduce expression.  So what happens if we pick the higher expressing gene to be in sub 1 and the lower expressing gene to be in sub 2?  Not surprising, we can find differences in populations between high and low expressing pairs.  I wonder if this holds across different maize lines?

```{r subgenome_expression_high_v_low, echo=FALSE, warning=FALSE, message=FALSE, results='hide', fig.width=4.5, fig.height=4, fig.align='center'}
data <- expressedPairs
data$LowExpressingGene <- apply(data[,c(3,4)], 1, FUN=min)
data$HighExpressingGene <- apply(data[,c(3,4)], 1, FUN=max)
data <- data %>% gather(key = type, value = value, 5:6)
ggplot(data, aes(type, log10(value))) +
  geom_boxplot() +
  labs(y = "log10(FPKM)",
       x = "Types",
       title = "Comparison of FPKM Expression between\nGenes in high express vs. low express groups"
  )
```

```{r subgenome_expression_dominance, echo=FALSE, warning=FALSE, message=FALSE, results='hide', fig.width=10, fig.height=4, fig.align='center'}
plot <- graphGenePairExpressionsByExperiement(maize.expression.all, homeologs.pairs, 2:12, 1, TRUE)
# plot <- graphGenePairExpressionsByExperiement(maize.expression.all, homeologs.pairs, 2:12, 4, FALSE)
plot(plot)
```

# Wrapup
***

The results of this report are available at **`r params$outputFile`**.

```{r writeSubgenomesToFile, echo=FALSE}
## Now recover which genes are in these sets
#write.table(subgenome, params$outputFile, sep="\t")
```
